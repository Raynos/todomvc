{
  "name": "watchables",
  "id": "watchables",
  "version": "0.0.3",
  "description": "Watchable value abstraction",
  "keywords": [
    "watchables",
    "polymorphic",
    "method",
    "abstraction"
  ],
  "author": {
    "name": "Irakli Gozalishvili",
    "email": "rfobic@gmail.com",
    "url": "http://jeditoolkit.com"
  },
  "homepage": "https://github.com/Gozala/watchables",
  "repository": {
    "type": "git",
    "url": "https://github.com/Gozala/watchables.git",
    "web": "https://github.com/Gozala/watchables"
  },
  "bugs": {
    "url": "http://github.com/Gozala/watchables/issues/"
  },
  "dependencies": {
    "method": ">=0.1.1"
  },
  "devDependencies": {
    "test": ">=0.4.4",
    "repl-utils": ">=1.0.0"
  },
  "scripts": {
    "test": "node test/test-all.js",
    "repl": "node node_modules/repl-utils"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/Gozala/watchables/License.md"
    }
  ],
  "readme": "# Watchables\n\n[![Build Status](https://secure.travis-ci.org/Gozala/watchables.png)](http://travis-ci.org/Gozala/watchables)\n\nLibrary defines watchable value abstraction, in form of three [polymorphic\nmethods][method], where each one can be extended per type.\n\n### watchers\n\n[watchables/watchers](./watchables/blob/master/watchers.js) module provides\nmethod that has no default implementation and supposed to be defined per type\nthat wishes to implement this watchable abstraction:\n\n```js\nvar watchers = require(\"watchables/watchers\")\nfunction Type() { /* ... */ }\nwatchers.define(Type, function(value) {\n  // return array of registered observes for the given value,\n  // wthich is instance of `Type`.\n})\n```\n\n### watch\n\n[watchables/watch](./watchables/blob/master/watch.js) module provides\npolymorphic method that comes with a default implementation. Given that it's\ncalled with a value that implements `watchers` method and a observer function,\nit will register given observer for the value unless it's already being\nregistered. Method can be defined for a specific type to better reflect\nit's needs.\n\n```js\nvar watch = require(\"wathchables/watch\")\nwatch(new Type(), function() {\n  console.log(\"!!!!\")\n})\n```\n\nMethod can also be extended with a type specific implementation.\n\n\n```js\nvar watch = require(\"wathchables/watch\")\nwatch.define(Type, function(value, listener) {\n  var listeners = value._listeners\n  if (typeof(listeners) === \"undefined\")\n    value._listeners = listener\n  else if (typeof(listeners) === \"function\")\n    value._listeners = [value._listeners, listener]\n  else\n    listeners.push(listener)\n})\n```\n\n\n### unwatch\n\n[watchables/unwatch](./watchables/blob/master/unwatch.js) module provides\npolymorphic method that comes with a default implementation. Given that it's\ncalled with a value that implements `watchers` method and a observer function,\nit will unregister given observer for the value, if it's registered.\n\n```js\nvar unwatch = require(\"wathchables/unwatch\")\nunwatch(value, myListener)\n```\n\nMethod can be extended with a type specific implementation.\n\n```js\nvar unwatch = require(\"wathchables/unwatch\")\nunwatch.define(Type, function(value, listener) {\n  var listeners = value._listeners\n  var index = -1\n  if (typeof(listeners) === \"function\") {\n    if (listeners === listener) value._listeners = void(0)\n  } else if (listeners && ~(index = listeners.indexOf(listener))) {\n    if (listeners.length === 2) {\n      value._listeners = index === 0 ? listeners[1] : listeners[0]\n    } else {\n      listeners.splice(index, 1)\n    }\n  }\n  return value\n})\n\n```\n\n\n## Install\n\n    npm install watchables\n\n[method]:https://github.com/Gozala/method\n",
  "_id": "watchables@0.0.3",
  "_from": "watchables@>=0.0.3"
}
