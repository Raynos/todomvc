{
  "name": "compound",
  "id": "compound",
  "version": "0.0.1",
  "description": "Chaining into lazy compound functions",
  "keywords": [
    "compound"
  ],
  "author": {
    "name": "Irakli Gozalishvili",
    "email": "rfobic@gmail.com",
    "url": "http://jeditoolkit.com"
  },
  "homepage": "https://github.com/Gozala/compound",
  "repository": {
    "type": "git",
    "url": "https://github.com/Gozala/compound.git",
    "web": "https://github.com/Gozala/compound"
  },
  "bugs": {
    "url": "http://github.com/Gozala/compound/issues/"
  },
  "main": "./compound.js",
  "devDependencies": {
    "test": ">=0.4.4",
    "repl-utils": ">=1.0.0"
  },
  "scripts": {
    "test": "node test/test-all.js",
    "repl": "node node_modules/repl-utils"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/Gozala/compound/License.md"
    }
  ],
  "readme": "# compound\n\n[![Build Status](https://secure.travis-ci.org/Gozala/compound.png)](http://travis-ci.org/Gozala/compound)\n\nThis is small function chaining library that allows one to make compound units\nof computation. Unlike very popular method chaining, this feels and behaves\ndifferently!\n\n### Unlimited\n\nOne of the main limitations of method chaining is that it's limited to the\npredefined set of methods. All the user space functions are second class\nthat is usually limiting. This library does not has this limitation as\nchaining happens on arbitrary functions:\n\n```js\nfunction descriptor(source) {\n  return Object.getOwnPropertyNames(source).reduce(function(result, name) {\n    result[name] = Object.getOwnPropertyDescriptor(source, name)\n    return result\n  }, {})\n}\n\nfunction merge() {\n  var sources = Array.prototype.slice.call(arguments)\n  var target = sources.shift()\n  var whitelist = {}\n  sources.forEach(function(source) {\n    var properties = descriptor(source)\n    Object.keys(properties).forEach(function(name) {\n      whitelist[name] = properties[name]\n    })\n  })\n  return Object.defineProperties(target, whitelist)\n}\n\nfunction pick() {\n  var names = Array.prototype.slice.call(arguments)\n  var source = names.shift()\n  var properties = descriptor(source)\n  var whitelist = {}\n  names.forEach(function(name) {\n    whitelist[name] = properties[name]\n  })\n  return Object.create(Object.getPrototypeOf(source), whitelist)\n}\n\nvar compound = require(\"compound\")\n\nvar hash = (compound)\n (merge, { x: 12, y: 13 })\n (pick, 'a', 'b', 'x')\n ({ a: 1, b: 2, c: 3, d: 4 })\n```\n\n### Lazy\n\nAnother key difference is that intermidiate values are not computed during\nchaining, instead chaining creates compound functions that can be invoked\nto perform all the chained computations.\n\n\n```js\nvar t = (compound)\n  (merge, { x: 12, y: 13 })\n  (pick, 'a', 'b', 'x')\n\ntypeof(t)                     // => function\nt({ a: 1, b: 2, c: 3, d: 4 }) // => { x: 12, a: 1, b: 2 }\n```\n\n### composable\n\nSince result of chaining is just an ordinary function, they can be further\ncompounded, or used in any other kind of functional composition.\n\n\n```js\nfunction method(name) {\n  return function methodCall(target) {\n    return target[name].apply(target, Array.prototype.slice.call(arguments, 1))\n  }\n}\n\nvar t1 = (compound)\n  (method(\"toUpperCase\"))\n  (method(\"replace\"), \"A\", \"X\")\n\nt1(\"a b c\")     // => \"X B C\"\n\nvar t2 = (compound)\n  (t1)\n  (method(\"split\"), \" \")\n  (method(\"join\"), \"-\")\n\nt2(\"a b c\")     // => \"X-B-C\"\n```\n\n## Install\n\n    npm install compound\n",
  "_id": "compound@0.0.1",
  "dist": {
    "shasum": "2dec2a2f46a8f8fcb5e8458f500e005d45e65ea0"
  },
  "_from": "compound@>=0.0.1"
}
